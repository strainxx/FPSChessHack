#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_KingChar

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "BP_PieceChar_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_KingChar.BP_KingChar_C
// 0x0100 (0x07F0 - 0x06F0)
class ABP_KingChar_C : public ABP_PieceChar_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_KingChar_C;                      // 0x06F0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, UObjectWrapper)
	class UNiagaraComponent*                      SlamProjEffect;                                    // 0x06F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UCapsuleComponent*                      HitBox;                                            // 0x0700(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UAudioComponent*                        BeamSFX;                                           // 0x0708(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UActorSequenceComponent*                UnslamSword;                                       // 0x0710(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UActorSequenceComponent*                SlamSword;                                         // 0x0718(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class USplineComponent*                       SlamPath;                                          // 0x0720(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UStaticMeshComponent*                   SlamProjection;                                    // 0x0728(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UActorSequenceComponent*                KingWalking;                                       // 0x0730(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UActorSequenceComponent*                KingBlocking;                                      // 0x0738(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UNiagaraComponent*                      SwordBeam;                                         // 0x0740(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UActorSequenceComponent*                ResetSwing;                                        // 0x0748(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UCapsuleComponent*                      BeamHitbox;                                        // 0x0750(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UActorSequenceComponent*                ThrustForward;                                     // 0x0758(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UActorSequenceComponent*                SwingBackwards;                                    // 0x0760(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	class UActorSequenceComponent*                SwingForwards;                                     // 0x0768(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	float                                         SlamUp_Time_D2150CB443D5A1C8718A42B3A9F28B72;      // 0x0770(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	ETimelineDirection                            SlamUp__Direction_D2150CB443D5A1C8718A42B3A9F28B72; // 0x0774(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_775[0x3];                                      // 0x0775(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     SlamUp;                                            // 0x0778(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	float                                         SlamDown_Height_FDEBE28444C91085AA75CC92D0F89247;  // 0x0780(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	ETimelineDirection                            SlamDown__Direction_FDEBE28444C91085AA75CC92D0F89247; // 0x0784(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_785[0x3];                                      // 0x0785(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     SlamDown;                                          // 0x0788(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	ETimelineDirection                            FiringBeam__Direction_F329958A4A49B03EEC0C44B5F6CF886D; // 0x0790(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_791[0x7];                                      // 0x0791(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     FiringBeam;                                        // 0x0798(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	bool                                          SwingingForward;                                   // 0x07A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_7A1[0x3];                                      // 0x07A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwordPushStrength;                                 // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BeamTime;                                          // 0x07A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BeamDPS;                                           // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BeamPullSpeed;                                     // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          _FiringBeam;                                       // 0x07B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          EnemyInvincible;                                   // 0x07B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_7B6[0x2];                                      // 0x07B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwingInvincibleTime;                               // 0x07B8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Recovering;                                        // 0x07BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          Slamming;                                          // 0x07BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_7BE[0x2];                                      // 0x07BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSlamRange;                                      // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Slammable;                                         // 0x07C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_7C5[0x3];                                      // 0x07C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlamHeight;                                        // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SlamPeakHeight;                                    // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SlamVelocity;                                      // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SlamLedgeHeight;                                   // 0x07D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class AActor*>                         NoHitList;                                         // 0x07D8(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	float                                         MinSlamLedgeDist;                                  // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          InAirSlamming;                                     // 0x07EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          Swinging;                                          // 0x07ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          CanHit;                                            // 0x07EE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)

public:
	void ExecuteUbergraph_BP_KingChar(int32 EntryPoint);
	void ForceSwing();
	void CheckForHits(class UPrimitiveComponent* Component, class AActor* Actor);
	void SwingPlayback();
	void SwingingEvent(bool Swinging_0);
	void SwingingServer(bool Swinging_0);
	void SwingingMulti(bool Swinging_0);
	void SwingingAll(bool Swinging_0);
	void EnableSwingHitbox();
	void SlamOver();
	void EndSlamPlayback(const struct FVector& Location);
	void StartSlamPlayback();
	void PlaybackEndBeam();
	void PlaybackStartBeam();
	void UnswingPlayback();
	void RecordUnswingServer();
	void RecordUnswingMulti();
	void RecordUnswing();
	void RecordSwingServer();
	void RecordSwingMulti();
	void RecordSwing();
	void DisableSlam();
	void SlamAll(const struct FVector& SlamPosition);
	void SlamServer(const struct FVector& SlamPosition);
	void SlamMulti(const struct FVector& SlamPosition);
	void Slam(const struct FVector& SlamPosition);
	void ProjectSlam();
	void TrailBackward();
	void TrailForward();
	void BndEvt__BP_KingChar_Hitbox_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void TurnOffInvincible();
	void TerminateBeamMulti();
	void TerminateBeamAll();
	void TerminateBeamServer();
	void TerminateBeam();
	void FireBeam();
	void DoneSwingingForward();
	void SlamDown__UpdateFunc();
	void SlamDown__FinishedFunc();
	void SlamUp__UpdateFunc();
	void SlamUp__FinishedFunc();
	void FiringBeam__UpdateFunc();
	void FiringBeam__FinishedFunc();
	void SequenceEvent__ENTRYPOINTBP_KingChar_0();
	void SequenceEvent__ENTRYPOINTBP_KingChar_1();
	void Start_Blocking();
	void StopAllPlaying();
	void ReceiveTick(float DeltaSeconds);
	void ShootDirection(const struct FVector& Direction);
	void MovementAbilityAll();
	void ShootOverEvent();
	void ReceiveBeginPlay();
	void MainAbility();
	void DeathCleanup();
	void MovementAbility();
	void CantPlayAnimations(bool* CantPlay);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_KingChar_C">();
	}
	static class ABP_KingChar_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_KingChar_C>();
	}
};
static_assert(alignof(ABP_KingChar_C) == 0x000010, "Wrong alignment on ABP_KingChar_C");
static_assert(sizeof(ABP_KingChar_C) == 0x0007F0, "Wrong size on ABP_KingChar_C");
static_assert(offsetof(ABP_KingChar_C, UberGraphFrame_BP_KingChar_C) == 0x0006F0, "Member 'ABP_KingChar_C::UberGraphFrame_BP_KingChar_C' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamProjEffect) == 0x0006F8, "Member 'ABP_KingChar_C::SlamProjEffect' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, HitBox) == 0x000700, "Member 'ABP_KingChar_C::HitBox' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, BeamSFX) == 0x000708, "Member 'ABP_KingChar_C::BeamSFX' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, UnslamSword) == 0x000710, "Member 'ABP_KingChar_C::UnslamSword' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamSword) == 0x000718, "Member 'ABP_KingChar_C::SlamSword' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamPath) == 0x000720, "Member 'ABP_KingChar_C::SlamPath' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamProjection) == 0x000728, "Member 'ABP_KingChar_C::SlamProjection' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, KingWalking) == 0x000730, "Member 'ABP_KingChar_C::KingWalking' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, KingBlocking) == 0x000738, "Member 'ABP_KingChar_C::KingBlocking' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SwordBeam) == 0x000740, "Member 'ABP_KingChar_C::SwordBeam' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, ResetSwing) == 0x000748, "Member 'ABP_KingChar_C::ResetSwing' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, BeamHitbox) == 0x000750, "Member 'ABP_KingChar_C::BeamHitbox' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, ThrustForward) == 0x000758, "Member 'ABP_KingChar_C::ThrustForward' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SwingBackwards) == 0x000760, "Member 'ABP_KingChar_C::SwingBackwards' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SwingForwards) == 0x000768, "Member 'ABP_KingChar_C::SwingForwards' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamUp_Time_D2150CB443D5A1C8718A42B3A9F28B72) == 0x000770, "Member 'ABP_KingChar_C::SlamUp_Time_D2150CB443D5A1C8718A42B3A9F28B72' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamUp__Direction_D2150CB443D5A1C8718A42B3A9F28B72) == 0x000774, "Member 'ABP_KingChar_C::SlamUp__Direction_D2150CB443D5A1C8718A42B3A9F28B72' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamUp) == 0x000778, "Member 'ABP_KingChar_C::SlamUp' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamDown_Height_FDEBE28444C91085AA75CC92D0F89247) == 0x000780, "Member 'ABP_KingChar_C::SlamDown_Height_FDEBE28444C91085AA75CC92D0F89247' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamDown__Direction_FDEBE28444C91085AA75CC92D0F89247) == 0x000784, "Member 'ABP_KingChar_C::SlamDown__Direction_FDEBE28444C91085AA75CC92D0F89247' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamDown) == 0x000788, "Member 'ABP_KingChar_C::SlamDown' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, FiringBeam__Direction_F329958A4A49B03EEC0C44B5F6CF886D) == 0x000790, "Member 'ABP_KingChar_C::FiringBeam__Direction_F329958A4A49B03EEC0C44B5F6CF886D' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, FiringBeam) == 0x000798, "Member 'ABP_KingChar_C::FiringBeam' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SwingingForward) == 0x0007A0, "Member 'ABP_KingChar_C::SwingingForward' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SwordPushStrength) == 0x0007A4, "Member 'ABP_KingChar_C::SwordPushStrength' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, BeamTime) == 0x0007A8, "Member 'ABP_KingChar_C::BeamTime' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, BeamDPS) == 0x0007AC, "Member 'ABP_KingChar_C::BeamDPS' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, BeamPullSpeed) == 0x0007B0, "Member 'ABP_KingChar_C::BeamPullSpeed' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, _FiringBeam) == 0x0007B4, "Member 'ABP_KingChar_C::_FiringBeam' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, EnemyInvincible) == 0x0007B5, "Member 'ABP_KingChar_C::EnemyInvincible' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SwingInvincibleTime) == 0x0007B8, "Member 'ABP_KingChar_C::SwingInvincibleTime' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, Recovering) == 0x0007BC, "Member 'ABP_KingChar_C::Recovering' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, Slamming) == 0x0007BD, "Member 'ABP_KingChar_C::Slamming' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, MaxSlamRange) == 0x0007C0, "Member 'ABP_KingChar_C::MaxSlamRange' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, Slammable) == 0x0007C4, "Member 'ABP_KingChar_C::Slammable' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamHeight) == 0x0007C8, "Member 'ABP_KingChar_C::SlamHeight' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamPeakHeight) == 0x0007CC, "Member 'ABP_KingChar_C::SlamPeakHeight' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamVelocity) == 0x0007D0, "Member 'ABP_KingChar_C::SlamVelocity' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, SlamLedgeHeight) == 0x0007D4, "Member 'ABP_KingChar_C::SlamLedgeHeight' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, NoHitList) == 0x0007D8, "Member 'ABP_KingChar_C::NoHitList' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, MinSlamLedgeDist) == 0x0007E8, "Member 'ABP_KingChar_C::MinSlamLedgeDist' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, InAirSlamming) == 0x0007EC, "Member 'ABP_KingChar_C::InAirSlamming' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, Swinging) == 0x0007ED, "Member 'ABP_KingChar_C::Swinging' has a wrong offset!");
static_assert(offsetof(ABP_KingChar_C, CanHit) == 0x0007EE, "Member 'ABP_KingChar_C::CanHit' has a wrong offset!");

}

