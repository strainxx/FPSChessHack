#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PieceChar

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PieceTypes_structs.hpp"
#include "Sounds_structs.hpp"
#include "KillcamEvents_structs.hpp"
#include "UMG_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_PieceChar.BP_PieceChar_C
// 0x0230 (0x06F0 - 0x04C0)
class ABP_PieceChar_C : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x04C0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, UObjectWrapper)
	class USphereComponent*                       HeadHitbox;                                        // 0x04C8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USkeletalMeshComponent*                 Weapon3P;                                          // 0x04D0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USkeletalMeshComponent*                 Weapon;                                            // 0x04D8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USpringArmComponent*                    SpringArm;                                         // 0x04E0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UKillcamRecorder_C*                     KillcamRecorder;                                   // 0x04E8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UActorSequenceComponent*                WalkBlockAnimation;                                // 0x04F0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UActorSequenceComponent*                WalkAnimation;                                     // 0x04F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UActorSequenceComponent*                FireAnimation;                                     // 0x0500(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DeathCamPos;                                       // 0x0508(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USpringArmComponent*                    DeathCam;                                          // 0x0510(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneCaptureComponent2D*               CrackCapture;                                      // 0x0518(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBoxComponent*                          BlockingBox;                                       // 0x0520(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UActorSequenceComponent*                BlockingAnimation;                                 // 0x0528(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        Joint;                                             // 0x0530(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        GunTransform;                                      // 0x0538(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        GunTip;                                            // 0x0540(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCameraComponent*                       FP_Camera;                                         // 0x0548(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	float                                         Timeline_1_Block_85D8ADDF4C0654DF88472098880E8CA8; // 0x0550(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	ETimelineDirection                            Timeline_1__Direction_85D8ADDF4C0654DF88472098880E8CA8; // 0x0554(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_555[0x3];                                      // 0x0555(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     Timeline_1;                                        // 0x0558(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         Timeline_0_Block_41A7A33047C3E00C28E0BDBEBF56AACA; // 0x0560(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	ETimelineDirection                            Timeline_0__Direction_41A7A33047C3E00C28E0BDBEBF56AACA; // 0x0564(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_565[0x3];                                      // 0x0565(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     Timeline_0;                                        // 0x0568(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_Square_C*                           BoardSquare;                                       // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Selected;                                          // 0x0578(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          Black;                                             // 0x0579(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor)
	uint8                                         Pad_57A[0x2];                                      // 0x057A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHealth;                                         // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         Health;                                            // 0x0580(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BulletSpeed;                                       // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_Square_C*                           ContestedSquare;                                   // 0x0588(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_Player_C*                           OwningPlayer;                                      // 0x0590(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	float                                         HitscanRange;                                      // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BulletStrength;                                    // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         Accuracy;                                          // 0x05A0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ShootDelay;                                        // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         HitmarkerDelay;                                    // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Shooting;                                          // 0x05AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_5AD[0x3];                                      // 0x05AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ShootingTimer;                                     // 0x05B0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UPieceHUD_C*                            PieceHUD;                                          // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Dead;                                              // 0x05C0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_Piece_C*                            RepresentedPiece;                                  // 0x05C8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_PieceChar_C*>                Opponents;                                         // 0x05D0(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	class ABP_ChessBoard_C*                       chessboard;                                        // 0x05E0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAbility;                                         // 0x05E8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_5E9[0x3];                                      // 0x05E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mainAbilityTimer;                                  // 0x05EC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MainAbilityCooldown;                               // 0x05F0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MovementAbilityTimer;                              // 0x05F4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MovementAbilityCooldown;                           // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                ControlVector;                                     // 0x05FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ShootDamage;                                       // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MouseSensitivity;                                  // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         blockRefreshRate;                                  // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         blockCooldown;                                     // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaxBlockedDamage;                                  // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Blocking;                                          // 0x061C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_61D[0x3];                                      // 0x061D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BlockStart;                                        // 0x0620(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                BlockEnd;                                          // 0x062C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         blockedDamage;                                     // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          blockRecharging;                                   // 0x063C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_63D[0x3];                                      // 0x063D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrevHealth;                                        // 0x0640(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_644[0x4];                                      // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_PieceChar_C*                        ParentPlayerPiece;                                 // 0x0648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          MovementBlocked;                                   // 0x0650(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          AbilitiesBlocked;                                  // 0x0651(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_652[0x2];                                      // 0x0652(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthRegenRate;                                   // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         HealthRegenCooldown;                               // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CanRegenHealth;                                    // 0x065C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_65D[0x3];                                      // 0x065D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RegenHealthTimer;                                  // 0x0660(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	float                                         RegenCrackUpdateInterval;                          // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RegenCrackTimer;                                   // 0x066C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          WallClimbing;                                      // 0x0670(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_671[0x3];                                      // 0x0671(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbSpeed;                                        // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ESounds                                       ShootSound;                                        // 0x0678(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_679[0x3];                                      // 0x0679(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDamageRange;                                    // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DamageFalloffRate;                                 // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MinDamage;                                         // 0x0684(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UActorSequenceComponent*                CurrentBlockingAnimation;                          // 0x0688(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UActorSequenceComponent*                CurrentFiringAnimation;                            // 0x0690(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AscendingWall;                                     // 0x0698(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          Walking;                                           // 0x0699(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_69A[0x6];                                      // 0x069A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorSequenceComponent*                CurrentWalkingAnimation;                           // 0x06A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DefaultWalkSpeed;                                  // 0x06A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CameraLocked;                                      // 0x06AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EPieceTypes                                   Piece_Type;                                        // 0x06AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Suicide;                                           // 0x06AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6AF[0x1];                                      // 0x06AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         crosshairDistance;                                 // 0x06B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              crosshairSize;                                     // 0x06B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6BC[0x4];                                      // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         TrailVFX;                                          // 0x06C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UNiagaraSystem*                         FireVFX;                                           // 0x06C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          playbackjumping;                                   // 0x06D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          InvertY;                                           // 0x06D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          chatOnCooldown;                                    // 0x06D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6D3[0x5];                                      // 0x06D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CurrentHitmarkerTimer;                             // 0x06D8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	int32                                         previoushitmarker;                                 // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              GamepadXY;                                         // 0x06E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CanHeadshot;                                       // 0x06EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          BSide;                                             // 0x06ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)

public:
	void ExecuteUbergraph_BP_PieceChar(int32 EntryPoint);
	void ReleaseFire();
	void PressFire();
	void SpecialDamageEffects(class ABP_PieceChar_C* Enemy, const struct FVector& Direction);
	void ReleaseBlock();
	void PressBlock();
	void InpAxisEvt_ChatWheelY_K2Node_InputAxisEvent_1(float AxisValue);
	void InpAxisEvt_ChatWheelX_K2Node_InputAxisEvent_0(float AxisValue);
	void HitmarkerStart(int32 Type);
	void ChatOffCooldown();
	void SendMessageToPlayers(const class FText& Message);
	void Send_New_Message(const class FText& Message, bool Player1);
	void CloseChat();
	void OpenChat();
	void Y_invert(bool NewParam);
	void UpdateSensitivity(float Sensitivity, bool Player2);
	void BndEvt__BP_PieceChar_BlockingBox_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void BlockShotServer(const struct FVector& Location, float Damage, class ABP_PieceChar_C* Enemy);
	void BlockShotMulti(const struct FVector& Location, float Damage, class ABP_PieceChar_C* Enemy);
	void DebugAllAnimations();
	void DebugAnimation(class UActorSequenceComponent* Target);
	void PlayShootSoundServer();
	void RecordDeath();
	void HitmarkerObjectPlayback();
	void HitmarkerHeadshotPlayback();
	void HitmarkerPlayerPlayback();
	void RecordHitmarker(int32 Type);
	void RecordHitmarkerServer(int32 Type);
	void RecordHitmarkerMulti(int32 Type);
	void RecordHitmarkerAll(int32 Type);
	void RecordCracksLocal(float CrackValue);
	void RecordCracksMulti(float CrackValue);
	void RecordCracksServer(float CrackValue);
	void PlaybackStopBlock();
	void PlaybackBlock();
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void CreateHUD(class APlayerController* OwningPlayer_0);
	void InitAsReplayActor();
	void RecordJointTransform();
	void UpdateMovementCooldownHUD();
	void UnhighlightMovementHUD();
	void HighlightMovementHUD();
	void PlayAnimationSequence(class UMovieSceneSequencePlayer* Target);
	void PlayAnimationMulti(class UMovieSceneSequencePlayer* Target);
	void PlayAnimationServer(class UMovieSceneSequencePlayer* Target);
	void PlayAnimationAll(class UMovieSceneSequencePlayer* Target);
	void CooldownMovementAbility();
	void MovementAbilityAll();
	void MovementAbilityServer();
	void MovementAbilityMulti();
	void StopAllPlaying();
	void UnhighlightAbilityHUD();
	void HighlightAbilityHUD();
	void PlayShootSound();
	void DamageProjectilePiece(class UObject* ActualObject, float Damage);
	void ExplodeEnemy(class ABP_PieceChar_C* Target);
	void Set_Winner(bool Tie, EPieceTypes Winner, bool Black_0);
	void CooldownMainAbility();
	void ShootDestructableAll(class ABP_Destructible_C* Object, float Damage, float ImpulseStrength);
	void ShootDestructableServer(class ABP_Destructible_C* Object, float Damage, float ImpulseStrength);
	void ShootDestructableMulti(class ABP_Destructible_C* Object, float Damage, float ImpulseStrength);
	void ShootDestructable(class ABP_Destructible_C* Object, float Damage, float ImpulseStrength);
	void MainAbilityAll();
	void MainAbilityServer();
	void HealAll(float Amount);
	void HealServer(float Amount);
	void HealMulti(float Amount);
	void Heal(float Amount);
	void SetCountdownOnClient(int32 Count);
	void UpdateCracks(float Amount);
	void DamageAll(float Amount, class ABP_PieceChar_C* Enemy, const struct FVector& Location);
	void DamageMulti(float Amount, class ABP_PieceChar_C* Enemy, const struct FVector& Location);
	void DamageServer(float Amount, class ABP_PieceChar_C* Enemy, const struct FVector& Location);
	void ShootEffectsAll(const struct FVector& Endpoint, const struct FVector& Direction);
	void ShootEffectsMulti(const struct FVector& Endpoint, const struct FVector& Direction);
	void ShootEffectsServer(const struct FVector& Endpoint, const struct FVector& Direction);
	void ShootObjectAll(class UPrimitiveComponent* Object, const struct FVector& Force, const struct FVector& Location, class UObject* ActualObject, float Damage, const struct FVector& Normal);
	void ShootObjectMulti(class UPrimitiveComponent* Object, const struct FVector& Force, const struct FVector& Location, class UObject* ActualObject, float Damage, const struct FVector& Normal);
	void ShootObjectServer(class UPrimitiveComponent* Object, const struct FVector& Force, const struct FVector& Location, class UObject* ActualObject, float Damage, const struct FVector& Normal);
	void ShootObject(class UPrimitiveComponent* Object, const struct FVector& Force, const struct FVector& Location, class UObject* ActualObject, float Damage, const struct FVector& Normal);
	void DieClient(class ABP_PieceChar_C* Piece);
	void ActivateHitmarkerHeadshotPieceChar();
	void ShootOverEvent();
	void StartRechargingBlock();
	void StopBlockingServer();
	void StartBlockingServer();
	void Start_Blocking();
	void Stop_Blocking();
	void StopCurrentTimelines();
	void BlockingAnimDone();
	void BlockShotLocal(const struct FVector& Location, float Damage, class ABP_PieceChar_C* Enemy);
	void MainAbilityMulti();
	void UpdateCooldownHUD();
	void SetGunRotation(const struct FRotator& Vector);
	void StopShooting(const struct FVector& Direction);
	void StartShooting(const struct FVector& Direction);
	void MoveChar(const struct FVector& Input_Vector);
	void TerminateHUD();
	void EndCombat();
	void DamageEnemy(float Amount, class ABP_PieceChar_C* Enemy, const struct FVector& Location);
	void SetRot(const struct FRotator& Rot);
	void ActivateHitmarkerPieceChar();
	void ShootEffects(const struct FVector& Endpoint, const struct FVector& Direction);
	void ActivateHitmarkerPiece();
	void ShootDirection(const struct FVector& Direction);
	void InitHUD();
	void Shoot();
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	void CreateAndExplodeDestructible();
	void UnlockMovement();
	void LockMovement();
	void Unlock_Abilities(float Delay);
	void LockAbilities();
	void SetGlowingPlayback(bool bValue);
	void SetGlowing(bool bValue);
	void EndJump();
	void StartJump();
	void ClimbServer();
	void ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void DisableAllInput();
	void InpAxisEvt_Pitch_K2Node_InputAxisEvent_8(float AxisValue);
	void InpAxisEvt_Yaw_K2Node_InputAxisEvent_7(float AxisValue);
	void InpAxisEvt_Left_K2Node_InputAxisEvent_6(float AxisValue);
	void InpAxisEvt_Backward_K2Node_InputAxisEvent_5(float AxisValue);
	void InpAxisEvt_Forward_K2Node_InputAxisEvent_2(float AxisValue);
	void InpAxisEvt_Right_K2Node_InputAxisEvent_3(float AxisValue);
	void InpActEvt_Open_Chat_Wheel_K2Node_InputActionEvent_0(const struct FKey& Key);
	void InpActEvt_Open_Chat_Wheel_K2Node_InputActionEvent_1(const struct FKey& Key);
	void InpActEvt_Block_K2Node_InputActionEvent_2(const struct FKey& Key);
	void InpActEvt_Block_K2Node_InputActionEvent_3(const struct FKey& Key);
	void InpActEvt_Fire_K2Node_InputActionEvent_4(const struct FKey& Key);
	void InpActEvt_Fire_K2Node_InputActionEvent_5(const struct FKey& Key);
	void InpActEvt_Movement_Ability_K2Node_InputActionEvent_6(const struct FKey& Key);
	void InpActEvt_Main_Ability_K2Node_InputActionEvent_7(const struct FKey& Key);
	void InpActEvt_Jump_K2Node_InputActionEvent_8(const struct FKey& Key);
	void InpActEvt_Jump_K2Node_InputActionEvent_9(const struct FKey& Key);
	void Timeline_1__UpdateFunc();
	void Timeline_1__FinishedFunc();
	void Timeline_0__UpdateFunc();
	void Timeline_0__FinishedFunc();
	void EnterCombatMode(class ABP_Piece_C* StaticChild);
	void Exit_Combat();
	void MainAbility();
	void FindClosestFriendlyPiece(bool PawnsOnly, class ABP_Piece_C** Closest_Piece);
	void PointInHead(const struct FVector& Point, bool* In_Head);
	void EnableHealthRegen();
	void DeathCleanup();
	void OverrideAnimateWalk(bool* Override);
	void MovementAbility();
	void CantPlayAnimations(bool* CantPlay);
	void OnRep_OwningPlayer();
	void GetDefaultCamera(class UCameraComponent** Default_Camera);
	void CalcShootDirection(struct FVector* Shoot_Direction);
	void OnRep_RepresentedPiece();
	void OnRep_Black();
	void FalloffFromDistance(float Distance, float* Damage);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_PieceChar_C">();
	}
	static class ABP_PieceChar_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_PieceChar_C>();
	}
};
static_assert(alignof(ABP_PieceChar_C) == 0x000010, "Wrong alignment on ABP_PieceChar_C");
static_assert(sizeof(ABP_PieceChar_C) == 0x0006F0, "Wrong size on ABP_PieceChar_C");
static_assert(offsetof(ABP_PieceChar_C, UberGraphFrame) == 0x0004C0, "Member 'ABP_PieceChar_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, HeadHitbox) == 0x0004C8, "Member 'ABP_PieceChar_C::HeadHitbox' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Weapon3P) == 0x0004D0, "Member 'ABP_PieceChar_C::Weapon3P' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Weapon) == 0x0004D8, "Member 'ABP_PieceChar_C::Weapon' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, SpringArm) == 0x0004E0, "Member 'ABP_PieceChar_C::SpringArm' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, KillcamRecorder) == 0x0004E8, "Member 'ABP_PieceChar_C::KillcamRecorder' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, WalkBlockAnimation) == 0x0004F0, "Member 'ABP_PieceChar_C::WalkBlockAnimation' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, WalkAnimation) == 0x0004F8, "Member 'ABP_PieceChar_C::WalkAnimation' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, FireAnimation) == 0x000500, "Member 'ABP_PieceChar_C::FireAnimation' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, DeathCamPos) == 0x000508, "Member 'ABP_PieceChar_C::DeathCamPos' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, DeathCam) == 0x000510, "Member 'ABP_PieceChar_C::DeathCam' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, CrackCapture) == 0x000518, "Member 'ABP_PieceChar_C::CrackCapture' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, BlockingBox) == 0x000520, "Member 'ABP_PieceChar_C::BlockingBox' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, BlockingAnimation) == 0x000528, "Member 'ABP_PieceChar_C::BlockingAnimation' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Joint) == 0x000530, "Member 'ABP_PieceChar_C::Joint' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, GunTransform) == 0x000538, "Member 'ABP_PieceChar_C::GunTransform' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, GunTip) == 0x000540, "Member 'ABP_PieceChar_C::GunTip' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, FP_Camera) == 0x000548, "Member 'ABP_PieceChar_C::FP_Camera' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Timeline_1_Block_85D8ADDF4C0654DF88472098880E8CA8) == 0x000550, "Member 'ABP_PieceChar_C::Timeline_1_Block_85D8ADDF4C0654DF88472098880E8CA8' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Timeline_1__Direction_85D8ADDF4C0654DF88472098880E8CA8) == 0x000554, "Member 'ABP_PieceChar_C::Timeline_1__Direction_85D8ADDF4C0654DF88472098880E8CA8' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Timeline_1) == 0x000558, "Member 'ABP_PieceChar_C::Timeline_1' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Timeline_0_Block_41A7A33047C3E00C28E0BDBEBF56AACA) == 0x000560, "Member 'ABP_PieceChar_C::Timeline_0_Block_41A7A33047C3E00C28E0BDBEBF56AACA' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Timeline_0__Direction_41A7A33047C3E00C28E0BDBEBF56AACA) == 0x000564, "Member 'ABP_PieceChar_C::Timeline_0__Direction_41A7A33047C3E00C28E0BDBEBF56AACA' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Timeline_0) == 0x000568, "Member 'ABP_PieceChar_C::Timeline_0' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, BoardSquare) == 0x000570, "Member 'ABP_PieceChar_C::BoardSquare' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Selected) == 0x000578, "Member 'ABP_PieceChar_C::Selected' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Black) == 0x000579, "Member 'ABP_PieceChar_C::Black' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MaxHealth) == 0x00057C, "Member 'ABP_PieceChar_C::MaxHealth' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Health) == 0x000580, "Member 'ABP_PieceChar_C::Health' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, BulletSpeed) == 0x000584, "Member 'ABP_PieceChar_C::BulletSpeed' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, ContestedSquare) == 0x000588, "Member 'ABP_PieceChar_C::ContestedSquare' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, OwningPlayer) == 0x000590, "Member 'ABP_PieceChar_C::OwningPlayer' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, HitscanRange) == 0x000598, "Member 'ABP_PieceChar_C::HitscanRange' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, BulletStrength) == 0x00059C, "Member 'ABP_PieceChar_C::BulletStrength' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Accuracy) == 0x0005A0, "Member 'ABP_PieceChar_C::Accuracy' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, ShootDelay) == 0x0005A4, "Member 'ABP_PieceChar_C::ShootDelay' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, HitmarkerDelay) == 0x0005A8, "Member 'ABP_PieceChar_C::HitmarkerDelay' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Shooting) == 0x0005AC, "Member 'ABP_PieceChar_C::Shooting' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, ShootingTimer) == 0x0005B0, "Member 'ABP_PieceChar_C::ShootingTimer' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, PieceHUD) == 0x0005B8, "Member 'ABP_PieceChar_C::PieceHUD' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Dead) == 0x0005C0, "Member 'ABP_PieceChar_C::Dead' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, RepresentedPiece) == 0x0005C8, "Member 'ABP_PieceChar_C::RepresentedPiece' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Opponents) == 0x0005D0, "Member 'ABP_PieceChar_C::Opponents' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, chessboard) == 0x0005E0, "Member 'ABP_PieceChar_C::chessboard' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, IsAbility) == 0x0005E8, "Member 'ABP_PieceChar_C::IsAbility' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, mainAbilityTimer) == 0x0005EC, "Member 'ABP_PieceChar_C::mainAbilityTimer' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MainAbilityCooldown) == 0x0005F0, "Member 'ABP_PieceChar_C::MainAbilityCooldown' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MovementAbilityTimer) == 0x0005F4, "Member 'ABP_PieceChar_C::MovementAbilityTimer' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MovementAbilityCooldown) == 0x0005F8, "Member 'ABP_PieceChar_C::MovementAbilityCooldown' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, ControlVector) == 0x0005FC, "Member 'ABP_PieceChar_C::ControlVector' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, ShootDamage) == 0x000608, "Member 'ABP_PieceChar_C::ShootDamage' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MouseSensitivity) == 0x00060C, "Member 'ABP_PieceChar_C::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, blockRefreshRate) == 0x000610, "Member 'ABP_PieceChar_C::blockRefreshRate' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, blockCooldown) == 0x000614, "Member 'ABP_PieceChar_C::blockCooldown' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MaxBlockedDamage) == 0x000618, "Member 'ABP_PieceChar_C::MaxBlockedDamage' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Blocking) == 0x00061C, "Member 'ABP_PieceChar_C::Blocking' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, BlockStart) == 0x000620, "Member 'ABP_PieceChar_C::BlockStart' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, BlockEnd) == 0x00062C, "Member 'ABP_PieceChar_C::BlockEnd' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, blockedDamage) == 0x000638, "Member 'ABP_PieceChar_C::blockedDamage' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, blockRecharging) == 0x00063C, "Member 'ABP_PieceChar_C::blockRecharging' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, PrevHealth) == 0x000640, "Member 'ABP_PieceChar_C::PrevHealth' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, ParentPlayerPiece) == 0x000648, "Member 'ABP_PieceChar_C::ParentPlayerPiece' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MovementBlocked) == 0x000650, "Member 'ABP_PieceChar_C::MovementBlocked' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, AbilitiesBlocked) == 0x000651, "Member 'ABP_PieceChar_C::AbilitiesBlocked' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, HealthRegenRate) == 0x000654, "Member 'ABP_PieceChar_C::HealthRegenRate' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, HealthRegenCooldown) == 0x000658, "Member 'ABP_PieceChar_C::HealthRegenCooldown' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, CanRegenHealth) == 0x00065C, "Member 'ABP_PieceChar_C::CanRegenHealth' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, RegenHealthTimer) == 0x000660, "Member 'ABP_PieceChar_C::RegenHealthTimer' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, RegenCrackUpdateInterval) == 0x000668, "Member 'ABP_PieceChar_C::RegenCrackUpdateInterval' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, RegenCrackTimer) == 0x00066C, "Member 'ABP_PieceChar_C::RegenCrackTimer' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, WallClimbing) == 0x000670, "Member 'ABP_PieceChar_C::WallClimbing' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, ClimbSpeed) == 0x000674, "Member 'ABP_PieceChar_C::ClimbSpeed' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, ShootSound) == 0x000678, "Member 'ABP_PieceChar_C::ShootSound' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MaxDamageRange) == 0x00067C, "Member 'ABP_PieceChar_C::MaxDamageRange' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, DamageFalloffRate) == 0x000680, "Member 'ABP_PieceChar_C::DamageFalloffRate' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, MinDamage) == 0x000684, "Member 'ABP_PieceChar_C::MinDamage' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, CurrentBlockingAnimation) == 0x000688, "Member 'ABP_PieceChar_C::CurrentBlockingAnimation' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, CurrentFiringAnimation) == 0x000690, "Member 'ABP_PieceChar_C::CurrentFiringAnimation' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, AscendingWall) == 0x000698, "Member 'ABP_PieceChar_C::AscendingWall' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Walking) == 0x000699, "Member 'ABP_PieceChar_C::Walking' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, CurrentWalkingAnimation) == 0x0006A0, "Member 'ABP_PieceChar_C::CurrentWalkingAnimation' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, DefaultWalkSpeed) == 0x0006A8, "Member 'ABP_PieceChar_C::DefaultWalkSpeed' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, CameraLocked) == 0x0006AC, "Member 'ABP_PieceChar_C::CameraLocked' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Piece_Type) == 0x0006AD, "Member 'ABP_PieceChar_C::Piece_Type' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, Suicide) == 0x0006AE, "Member 'ABP_PieceChar_C::Suicide' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, crosshairDistance) == 0x0006B0, "Member 'ABP_PieceChar_C::crosshairDistance' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, crosshairSize) == 0x0006B4, "Member 'ABP_PieceChar_C::crosshairSize' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, TrailVFX) == 0x0006C0, "Member 'ABP_PieceChar_C::TrailVFX' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, FireVFX) == 0x0006C8, "Member 'ABP_PieceChar_C::FireVFX' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, playbackjumping) == 0x0006D0, "Member 'ABP_PieceChar_C::playbackjumping' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, InvertY) == 0x0006D1, "Member 'ABP_PieceChar_C::InvertY' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, chatOnCooldown) == 0x0006D2, "Member 'ABP_PieceChar_C::chatOnCooldown' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, CurrentHitmarkerTimer) == 0x0006D8, "Member 'ABP_PieceChar_C::CurrentHitmarkerTimer' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, previoushitmarker) == 0x0006E0, "Member 'ABP_PieceChar_C::previoushitmarker' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, GamepadXY) == 0x0006E4, "Member 'ABP_PieceChar_C::GamepadXY' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, CanHeadshot) == 0x0006EC, "Member 'ABP_PieceChar_C::CanHeadshot' has a wrong offset!");
static_assert(offsetof(ABP_PieceChar_C, BSide) == 0x0006ED, "Member 'ABP_PieceChar_C::BSide' has a wrong offset!");

}

