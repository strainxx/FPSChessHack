#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PieceChar

#include "Basic.hpp"

#include "BP_PieceChar_classes.hpp"
#include "BP_PieceChar_parameters.hpp"


namespace SDK
{

// Function BP_PieceChar.BP_PieceChar_C.ExecuteUbergraph_BP_PieceChar
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ExecuteUbergraph_BP_PieceChar(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ExecuteUbergraph_BP_PieceChar");

	Params::BP_PieceChar_C_ExecuteUbergraph_BP_PieceChar Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ReleaseFire
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::ReleaseFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ReleaseFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.PressFire
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::PressFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PressFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.SpecialDamageEffects
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PieceChar_C*                  Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::SpecialDamageEffects(class ABP_PieceChar_C* Enemy, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "SpecialDamageEffects");

	Params::BP_PieceChar_C_SpecialDamageEffects Parms{};

	Parms.Enemy = Enemy;
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ReleaseBlock
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::ReleaseBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ReleaseBlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.PressBlock
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::PressBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PressBlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.InpAxisEvt_ChatWheelY_K2Node_InputAxisEvent_1
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::InpAxisEvt_ChatWheelY_K2Node_InputAxisEvent_1(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpAxisEvt_ChatWheelY_K2Node_InputAxisEvent_1");

	Params::BP_PieceChar_C_InpAxisEvt_ChatWheelY_K2Node_InputAxisEvent_1 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpAxisEvt_ChatWheelX_K2Node_InputAxisEvent_0
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::InpAxisEvt_ChatWheelX_K2Node_InputAxisEvent_0(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpAxisEvt_ChatWheelX_K2Node_InputAxisEvent_0");

	Params::BP_PieceChar_C_InpAxisEvt_ChatWheelX_K2Node_InputAxisEvent_0 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.HitmarkerStart
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::HitmarkerStart(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HitmarkerStart");

	Params::BP_PieceChar_C_HitmarkerStart Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ChatOffCooldown
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::ChatOffCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ChatOffCooldown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.SendMessageToPlayers
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Message                                                (BlueprintVisible, BlueprintReadOnly, Parm)

void ABP_PieceChar_C::SendMessageToPlayers(const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "SendMessageToPlayers");

	Params::BP_PieceChar_C_SendMessageToPlayers Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.Send New Message
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Message                                                (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    Player1                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::Send_New_Message(const class FText& Message, bool Player1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Send New Message");

	Params::BP_PieceChar_C_Send_New_Message Parms{};

	Parms.Message = std::move(Message);
	Parms.Player1 = Player1;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.CloseChat
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::CloseChat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "CloseChat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.OpenChat
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::OpenChat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "OpenChat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.Y invert
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewParam                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::Y_invert(bool NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Y invert");

	Params::BP_PieceChar_C_Y_invert Parms{};

	Parms.NewParam = NewParam;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.UpdateSensitivity
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Sensitivity                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Player2                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::UpdateSensitivity(float Sensitivity, bool Player2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "UpdateSensitivity");

	Params::BP_PieceChar_C_UpdateSensitivity Parms{};

	Parms.Sensitivity = Sensitivity;
	Parms.Player2 = Player2;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.BndEvt__BP_PieceChar_BlockingBox_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_PieceChar_C::BndEvt__BP_PieceChar_BlockingBox_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "BndEvt__BP_PieceChar_BlockingBox_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_PieceChar_C_BndEvt__BP_PieceChar_BlockingBox_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.BlockShotServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PieceChar_C*                  Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::BlockShotServer(const struct FVector& Location, float Damage, class ABP_PieceChar_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "BlockShotServer");

	Params::BP_PieceChar_C_BlockShotServer Parms{};

	Parms.Location = std::move(Location);
	Parms.Damage = Damage;
	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.BlockShotMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PieceChar_C*                  Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::BlockShotMulti(const struct FVector& Location, float Damage, class ABP_PieceChar_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "BlockShotMulti");

	Params::BP_PieceChar_C_BlockShotMulti Parms{};

	Parms.Location = std::move(Location);
	Parms.Damage = Damage;
	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.DebugAllAnimations
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::DebugAllAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DebugAllAnimations");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.DebugAnimation
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UActorSequenceComponent*          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::DebugAnimation(class UActorSequenceComponent* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DebugAnimation");

	Params::BP_PieceChar_C_DebugAnimation Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.PlayShootSoundServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::PlayShootSoundServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PlayShootSoundServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordDeath
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::RecordDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.HitmarkerObjectPlayback
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::HitmarkerObjectPlayback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HitmarkerObjectPlayback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.HitmarkerHeadshotPlayback
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::HitmarkerHeadshotPlayback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HitmarkerHeadshotPlayback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.HitmarkerPlayerPlayback
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::HitmarkerPlayerPlayback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HitmarkerPlayerPlayback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordHitmarker
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::RecordHitmarker(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordHitmarker");

	Params::BP_PieceChar_C_RecordHitmarker Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordHitmarkerServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::RecordHitmarkerServer(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordHitmarkerServer");

	Params::BP_PieceChar_C_RecordHitmarkerServer Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordHitmarkerMulti
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::RecordHitmarkerMulti(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordHitmarkerMulti");

	Params::BP_PieceChar_C_RecordHitmarkerMulti Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordHitmarkerAll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::RecordHitmarkerAll(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordHitmarkerAll");

	Params::BP_PieceChar_C_RecordHitmarkerAll Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordCracksLocal
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CrackValue                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::RecordCracksLocal(float CrackValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordCracksLocal");

	Params::BP_PieceChar_C_RecordCracksLocal Parms{};

	Parms.CrackValue = CrackValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordCracksMulti
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CrackValue                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::RecordCracksMulti(float CrackValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordCracksMulti");

	Params::BP_PieceChar_C_RecordCracksMulti Parms{};

	Parms.CrackValue = CrackValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordCracksServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CrackValue                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::RecordCracksServer(float CrackValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordCracksServer");

	Params::BP_PieceChar_C_RecordCracksServer Parms{};

	Parms.CrackValue = CrackValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.PlaybackStopBlock
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::PlaybackStopBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PlaybackStopBlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.PlaybackBlock
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::PlaybackBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PlaybackBlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ReceiveEndPlay");

	Params::BP_PieceChar_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.CreateHUD
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                OwningPlayer_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void ABP_PieceChar_C::CreateHUD(class APlayerController* OwningPlayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "CreateHUD");

	Params::BP_PieceChar_C_CreateHUD Parms{};

	Parms.OwningPlayer_0 = OwningPlayer_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InitAsReplayActor
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::InitAsReplayActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InitAsReplayActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.RecordJointTransform
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::RecordJointTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "RecordJointTransform");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.UpdateMovementCooldownHUD
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::UpdateMovementCooldownHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "UpdateMovementCooldownHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.UnhighlightMovementHUD
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::UnhighlightMovementHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "UnhighlightMovementHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.HighlightMovementHUD
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::HighlightMovementHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HighlightMovementHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.PlayAnimationSequence
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMovieSceneSequencePlayer*        Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void ABP_PieceChar_C::PlayAnimationSequence(class UMovieSceneSequencePlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PlayAnimationSequence");

	Params::BP_PieceChar_C_PlayAnimationSequence Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.PlayAnimationMulti
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMovieSceneSequencePlayer*        Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void ABP_PieceChar_C::PlayAnimationMulti(class UMovieSceneSequencePlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PlayAnimationMulti");

	Params::BP_PieceChar_C_PlayAnimationMulti Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.PlayAnimationServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMovieSceneSequencePlayer*        Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void ABP_PieceChar_C::PlayAnimationServer(class UMovieSceneSequencePlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PlayAnimationServer");

	Params::BP_PieceChar_C_PlayAnimationServer Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.PlayAnimationAll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMovieSceneSequencePlayer*        Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void ABP_PieceChar_C::PlayAnimationAll(class UMovieSceneSequencePlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PlayAnimationAll");

	Params::BP_PieceChar_C_PlayAnimationAll Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.CooldownMovementAbility
// (Net, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::CooldownMovementAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "CooldownMovementAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.MovementAbilityAll
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::MovementAbilityAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MovementAbilityAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.MovementAbilityServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::MovementAbilityServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MovementAbilityServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.MovementAbilityMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::MovementAbilityMulti()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MovementAbilityMulti");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.StopAllPlaying
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::StopAllPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "StopAllPlaying");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.UnhighlightAbilityHUD
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::UnhighlightAbilityHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "UnhighlightAbilityHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.HighlightAbilityHUD
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::HighlightAbilityHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HighlightAbilityHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.PlayShootSound
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::PlayShootSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PlayShootSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.DamageProjectilePiece
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          ActualObject                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::DamageProjectilePiece(class UObject* ActualObject, float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DamageProjectilePiece");

	Params::BP_PieceChar_C_DamageProjectilePiece Parms{};

	Parms.ActualObject = ActualObject;
	Parms.Damage = Damage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ExplodeEnemy
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PieceChar_C*                  Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ExplodeEnemy(class ABP_PieceChar_C* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ExplodeEnemy");

	Params::BP_PieceChar_C_ExplodeEnemy Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.Set Winner
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Tie                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPieceTypes                             Winner                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Black_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::Set_Winner(bool Tie, EPieceTypes Winner, bool Black_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Set Winner");

	Params::BP_PieceChar_C_Set_Winner Parms{};

	Parms.Tie = Tie;
	Parms.Winner = Winner;
	Parms.Black_0 = Black_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.CooldownMainAbility
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::CooldownMainAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "CooldownMainAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootDestructableAll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Destructible_C*               Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ImpulseStrength                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootDestructableAll(class ABP_Destructible_C* Object, float Damage, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootDestructableAll");

	Params::BP_PieceChar_C_ShootDestructableAll Parms{};

	Parms.Object = Object;
	Parms.Damage = Damage;
	Parms.ImpulseStrength = ImpulseStrength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootDestructableServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Destructible_C*               Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ImpulseStrength                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootDestructableServer(class ABP_Destructible_C* Object, float Damage, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootDestructableServer");

	Params::BP_PieceChar_C_ShootDestructableServer Parms{};

	Parms.Object = Object;
	Parms.Damage = Damage;
	Parms.ImpulseStrength = ImpulseStrength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootDestructableMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Destructible_C*               Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ImpulseStrength                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootDestructableMulti(class ABP_Destructible_C* Object, float Damage, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootDestructableMulti");

	Params::BP_PieceChar_C_ShootDestructableMulti Parms{};

	Parms.Object = Object;
	Parms.Damage = Damage;
	Parms.ImpulseStrength = ImpulseStrength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootDestructable
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Destructible_C*               Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ImpulseStrength                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootDestructable(class ABP_Destructible_C* Object, float Damage, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootDestructable");

	Params::BP_PieceChar_C_ShootDestructable Parms{};

	Parms.Object = Object;
	Parms.Damage = Damage;
	Parms.ImpulseStrength = ImpulseStrength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.MainAbilityAll
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::MainAbilityAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MainAbilityAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.MainAbilityServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::MainAbilityServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MainAbilityServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.HealAll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::HealAll(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HealAll");

	Params::BP_PieceChar_C_HealAll Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.HealServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::HealServer(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HealServer");

	Params::BP_PieceChar_C_HealServer Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.HealMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::HealMulti(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "HealMulti");

	Params::BP_PieceChar_C_HealMulti Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.Heal
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::Heal(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Heal");

	Params::BP_PieceChar_C_Heal Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.SetCountdownOnClient
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::SetCountdownOnClient(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "SetCountdownOnClient");

	Params::BP_PieceChar_C_SetCountdownOnClient Parms{};

	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.UpdateCracks
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::UpdateCracks(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "UpdateCracks");

	Params::BP_PieceChar_C_UpdateCracks Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.DamageAll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PieceChar_C*                  Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::DamageAll(float Amount, class ABP_PieceChar_C* Enemy, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DamageAll");

	Params::BP_PieceChar_C_DamageAll Parms{};

	Parms.Amount = Amount;
	Parms.Enemy = Enemy;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.DamageMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PieceChar_C*                  Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::DamageMulti(float Amount, class ABP_PieceChar_C* Enemy, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DamageMulti");

	Params::BP_PieceChar_C_DamageMulti Parms{};

	Parms.Amount = Amount;
	Parms.Enemy = Enemy;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.DamageServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PieceChar_C*                  Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::DamageServer(float Amount, class ABP_PieceChar_C* Enemy, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DamageServer");

	Params::BP_PieceChar_C_DamageServer Parms{};

	Parms.Amount = Amount;
	Parms.Enemy = Enemy;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootEffectsAll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Endpoint                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootEffectsAll(const struct FVector& Endpoint, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootEffectsAll");

	Params::BP_PieceChar_C_ShootEffectsAll Parms{};

	Parms.Endpoint = std::move(Endpoint);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootEffectsMulti
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Endpoint                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootEffectsMulti(const struct FVector& Endpoint, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootEffectsMulti");

	Params::BP_PieceChar_C_ShootEffectsMulti Parms{};

	Parms.Endpoint = std::move(Endpoint);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootEffectsServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Endpoint                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootEffectsServer(const struct FVector& Endpoint, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootEffectsServer");

	Params::BP_PieceChar_C_ShootEffectsServer Parms{};

	Parms.Endpoint = std::move(Endpoint);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootObjectAll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          ActualObject                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootObjectAll(class UPrimitiveComponent* Object, const struct FVector& Force, const struct FVector& Location, class UObject* ActualObject, float Damage, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootObjectAll");

	Params::BP_PieceChar_C_ShootObjectAll Parms{};

	Parms.Object = Object;
	Parms.Force = std::move(Force);
	Parms.Location = std::move(Location);
	Parms.ActualObject = ActualObject;
	Parms.Damage = Damage;
	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootObjectMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          ActualObject                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootObjectMulti(class UPrimitiveComponent* Object, const struct FVector& Force, const struct FVector& Location, class UObject* ActualObject, float Damage, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootObjectMulti");

	Params::BP_PieceChar_C_ShootObjectMulti Parms{};

	Parms.Object = Object;
	Parms.Force = std::move(Force);
	Parms.Location = std::move(Location);
	Parms.ActualObject = ActualObject;
	Parms.Damage = Damage;
	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootObjectServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          ActualObject                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootObjectServer(class UPrimitiveComponent* Object, const struct FVector& Force, const struct FVector& Location, class UObject* ActualObject, float Damage, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootObjectServer");

	Params::BP_PieceChar_C_ShootObjectServer Parms{};

	Parms.Object = Object;
	Parms.Force = std::move(Force);
	Parms.Location = std::move(Location);
	Parms.ActualObject = ActualObject;
	Parms.Damage = Damage;
	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootObject
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          ActualObject                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootObject(class UPrimitiveComponent* Object, const struct FVector& Force, const struct FVector& Location, class UObject* ActualObject, float Damage, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootObject");

	Params::BP_PieceChar_C_ShootObject Parms{};

	Parms.Object = Object;
	Parms.Force = std::move(Force);
	Parms.Location = std::move(Location);
	Parms.ActualObject = ActualObject;
	Parms.Damage = Damage;
	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.DieClient
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PieceChar_C*                  Piece                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::DieClient(class ABP_PieceChar_C* Piece)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DieClient");

	Params::BP_PieceChar_C_DieClient Parms{};

	Parms.Piece = Piece;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ActivateHitmarkerHeadshotPieceChar
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::ActivateHitmarkerHeadshotPieceChar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ActivateHitmarkerHeadshotPieceChar");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootOverEvent
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::ShootOverEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootOverEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.StartRechargingBlock
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::StartRechargingBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "StartRechargingBlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.StopBlockingServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::StopBlockingServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "StopBlockingServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.StartBlockingServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::StartBlockingServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "StartBlockingServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.Start Blocking
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::Start_Blocking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Start Blocking");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.Stop Blocking
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::Stop_Blocking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Stop Blocking");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.StopCurrentTimelines
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::StopCurrentTimelines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "StopCurrentTimelines");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.BlockingAnimDone
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::BlockingAnimDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "BlockingAnimDone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.BlockShotLocal
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PieceChar_C*                  Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::BlockShotLocal(const struct FVector& Location, float Damage, class ABP_PieceChar_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "BlockShotLocal");

	Params::BP_PieceChar_C_BlockShotLocal Parms{};

	Parms.Location = std::move(Location);
	Parms.Damage = Damage;
	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.MainAbilityMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::MainAbilityMulti()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MainAbilityMulti");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.UpdateCooldownHUD
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::UpdateCooldownHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "UpdateCooldownHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.SetGunRotation
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Vector                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::SetGunRotation(const struct FRotator& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "SetGunRotation");

	Params::BP_PieceChar_C_SetGunRotation Parms{};

	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.StopShooting
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::StopShooting(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "StopShooting");

	Params::BP_PieceChar_C_StopShooting Parms{};

	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.StartShooting
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::StartShooting(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "StartShooting");

	Params::BP_PieceChar_C_StartShooting Parms{};

	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.MoveChar
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Input_Vector                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::MoveChar(const struct FVector& Input_Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MoveChar");

	Params::BP_PieceChar_C_MoveChar Parms{};

	Parms.Input_Vector = std::move(Input_Vector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.TerminateHUD
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::TerminateHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "TerminateHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.EndCombat
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::EndCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "EndCombat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.DamageEnemy
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PieceChar_C*                  Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::DamageEnemy(float Amount, class ABP_PieceChar_C* Enemy, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DamageEnemy");

	Params::BP_PieceChar_C_DamageEnemy Parms{};

	Parms.Amount = Amount;
	Parms.Enemy = Enemy;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.SetRot
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rot                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::SetRot(const struct FRotator& Rot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "SetRot");

	Params::BP_PieceChar_C_SetRot Parms{};

	Parms.Rot = std::move(Rot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ActivateHitmarkerPieceChar
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::ActivateHitmarkerPieceChar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ActivateHitmarkerPieceChar");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootEffects
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Endpoint                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootEffects(const struct FVector& Endpoint, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootEffects");

	Params::BP_PieceChar_C_ShootEffects Parms{};

	Parms.Endpoint = std::move(Endpoint);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ActivateHitmarkerPiece
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::ActivateHitmarkerPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ActivateHitmarkerPiece");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.ShootDirection
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ShootDirection(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ShootDirection");

	Params::BP_PieceChar_C_ShootDirection Parms{};

	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InitHUD
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::InitHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InitHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.Shoot
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::Shoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Shoot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ReceiveTick");

	Params::BP_PieceChar_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_PieceChar_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.CreateAndExplodeDestructible
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::CreateAndExplodeDestructible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "CreateAndExplodeDestructible");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.UnlockMovement
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::UnlockMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "UnlockMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.LockMovement
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::LockMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "LockMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.Unlock Abilities
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::Unlock_Abilities(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Unlock Abilities");

	Params::BP_PieceChar_C_Unlock_Abilities Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.LockAbilities
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::LockAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "LockAbilities");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.SetGlowingPlayback
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bValue                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::SetGlowingPlayback(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "SetGlowingPlayback");

	Params::BP_PieceChar_C_SetGlowingPlayback Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.SetGlowing
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bValue                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::SetGlowing(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "SetGlowing");

	Params::BP_PieceChar_C_SetGlowing Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.EndJump
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::EndJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "EndJump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.StartJump
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::StartJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "StartJump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.ClimbServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::ClimbServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ClimbServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.ReceiveHit
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              MyComp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Other                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bSelfMoved                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_PieceChar_C::ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "ReceiveHit");

	Params::BP_PieceChar_C_ReceiveHit Parms{};

	Parms.MyComp = MyComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.bSelfMoved = bSelfMoved;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.DisableAllInput
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::DisableAllInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DisableAllInput");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.InpAxisEvt_Pitch_K2Node_InputAxisEvent_8
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::InpAxisEvt_Pitch_K2Node_InputAxisEvent_8(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpAxisEvt_Pitch_K2Node_InputAxisEvent_8");

	Params::BP_PieceChar_C_InpAxisEvt_Pitch_K2Node_InputAxisEvent_8 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpAxisEvt_Yaw_K2Node_InputAxisEvent_7
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::InpAxisEvt_Yaw_K2Node_InputAxisEvent_7(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpAxisEvt_Yaw_K2Node_InputAxisEvent_7");

	Params::BP_PieceChar_C_InpAxisEvt_Yaw_K2Node_InputAxisEvent_7 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpAxisEvt_Left_K2Node_InputAxisEvent_6
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::InpAxisEvt_Left_K2Node_InputAxisEvent_6(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpAxisEvt_Left_K2Node_InputAxisEvent_6");

	Params::BP_PieceChar_C_InpAxisEvt_Left_K2Node_InputAxisEvent_6 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpAxisEvt_Backward_K2Node_InputAxisEvent_5
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::InpAxisEvt_Backward_K2Node_InputAxisEvent_5(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpAxisEvt_Backward_K2Node_InputAxisEvent_5");

	Params::BP_PieceChar_C_InpAxisEvt_Backward_K2Node_InputAxisEvent_5 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpAxisEvt_Forward_K2Node_InputAxisEvent_2
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::InpAxisEvt_Forward_K2Node_InputAxisEvent_2(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpAxisEvt_Forward_K2Node_InputAxisEvent_2");

	Params::BP_PieceChar_C_InpAxisEvt_Forward_K2Node_InputAxisEvent_2 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpAxisEvt_Right_K2Node_InputAxisEvent_3
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::InpAxisEvt_Right_K2Node_InputAxisEvent_3(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpAxisEvt_Right_K2Node_InputAxisEvent_3");

	Params::BP_PieceChar_C_InpAxisEvt_Right_K2Node_InputAxisEvent_3 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Open Chat Wheel_K2Node_InputActionEvent_0
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Open_Chat_Wheel_K2Node_InputActionEvent_0(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Open Chat Wheel_K2Node_InputActionEvent_0");

	Params::BP_PieceChar_C_InpActEvt_Open_Chat_Wheel_K2Node_InputActionEvent_0 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Open Chat Wheel_K2Node_InputActionEvent_1
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Open_Chat_Wheel_K2Node_InputActionEvent_1(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Open Chat Wheel_K2Node_InputActionEvent_1");

	Params::BP_PieceChar_C_InpActEvt_Open_Chat_Wheel_K2Node_InputActionEvent_1 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Block_K2Node_InputActionEvent_2
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Block_K2Node_InputActionEvent_2(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Block_K2Node_InputActionEvent_2");

	Params::BP_PieceChar_C_InpActEvt_Block_K2Node_InputActionEvent_2 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Block_K2Node_InputActionEvent_3
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Block_K2Node_InputActionEvent_3(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Block_K2Node_InputActionEvent_3");

	Params::BP_PieceChar_C_InpActEvt_Block_K2Node_InputActionEvent_3 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Fire_K2Node_InputActionEvent_4
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Fire_K2Node_InputActionEvent_4(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Fire_K2Node_InputActionEvent_4");

	Params::BP_PieceChar_C_InpActEvt_Fire_K2Node_InputActionEvent_4 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Fire_K2Node_InputActionEvent_5
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Fire_K2Node_InputActionEvent_5(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Fire_K2Node_InputActionEvent_5");

	Params::BP_PieceChar_C_InpActEvt_Fire_K2Node_InputActionEvent_5 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Movement Ability_K2Node_InputActionEvent_6
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Movement_Ability_K2Node_InputActionEvent_6(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Movement Ability_K2Node_InputActionEvent_6");

	Params::BP_PieceChar_C_InpActEvt_Movement_Ability_K2Node_InputActionEvent_6 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Main Ability_K2Node_InputActionEvent_7
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Main_Ability_K2Node_InputActionEvent_7(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Main Ability_K2Node_InputActionEvent_7");

	Params::BP_PieceChar_C_InpActEvt_Main_Ability_K2Node_InputActionEvent_7 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Jump_K2Node_InputActionEvent_8
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Jump_K2Node_InputActionEvent_8(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Jump_K2Node_InputActionEvent_8");

	Params::BP_PieceChar_C_InpActEvt_Jump_K2Node_InputActionEvent_8 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.InpActEvt_Jump_K2Node_InputActionEvent_9
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PieceChar_C::InpActEvt_Jump_K2Node_InputActionEvent_9(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "InpActEvt_Jump_K2Node_InputActionEvent_9");

	Params::BP_PieceChar_C_InpActEvt_Jump_K2Node_InputActionEvent_9 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.Timeline_1__UpdateFunc
// (BlueprintEvent)

void ABP_PieceChar_C::Timeline_1__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Timeline_1__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.Timeline_1__FinishedFunc
// (BlueprintEvent)

void ABP_PieceChar_C::Timeline_1__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Timeline_1__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.Timeline_0__UpdateFunc
// (BlueprintEvent)

void ABP_PieceChar_C::Timeline_0__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Timeline_0__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.Timeline_0__FinishedFunc
// (BlueprintEvent)

void ABP_PieceChar_C::Timeline_0__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Timeline_0__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.EnterCombatMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Piece_C*                      StaticChild                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::EnterCombatMode(class ABP_Piece_C* StaticChild)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "EnterCombatMode");

	Params::BP_PieceChar_C_EnterCombatMode Parms{};

	Parms.StaticChild = StaticChild;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PieceChar.BP_PieceChar_C.Exit Combat
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::Exit_Combat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "Exit Combat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.MainAbility
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::MainAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MainAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.FindClosestFriendlyPiece
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    PawnsOnly                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class ABP_Piece_C*                      Closest_Piece                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::FindClosestFriendlyPiece(bool PawnsOnly, class ABP_Piece_C** Closest_Piece)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "FindClosestFriendlyPiece");

	Params::BP_PieceChar_C_FindClosestFriendlyPiece Parms{};

	Parms.PawnsOnly = PawnsOnly;

	UObject::ProcessEvent(Func, &Parms);

	if (Closest_Piece != nullptr)
		*Closest_Piece = Parms.Closest_Piece;
}


// Function BP_PieceChar.BP_PieceChar_C.PointInHead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Point                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    In_Head                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::PointInHead(const struct FVector& Point, bool* In_Head)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "PointInHead");

	Params::BP_PieceChar_C_PointInHead Parms{};

	Parms.Point = std::move(Point);

	UObject::ProcessEvent(Func, &Parms);

	if (In_Head != nullptr)
		*In_Head = Parms.In_Head;
}


// Function BP_PieceChar.BP_PieceChar_C.EnableHealthRegen
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::EnableHealthRegen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "EnableHealthRegen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.DeathCleanup
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::DeathCleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "DeathCleanup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.OverrideAnimateWalk
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Override                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::OverrideAnimateWalk(bool* Override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "OverrideAnimateWalk");

	Params::BP_PieceChar_C_OverrideAnimateWalk Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Override != nullptr)
		*Override = Parms.Override;
}


// Function BP_PieceChar.BP_PieceChar_C.MovementAbility
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::MovementAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "MovementAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.CantPlayAnimations
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CantPlay                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PieceChar_C::CantPlayAnimations(bool* CantPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "CantPlayAnimations");

	Params::BP_PieceChar_C_CantPlayAnimations Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CantPlay != nullptr)
		*CantPlay = Parms.CantPlay;
}


// Function BP_PieceChar.BP_PieceChar_C.OnRep_OwningPlayer
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::OnRep_OwningPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "OnRep_OwningPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.GetDefaultCamera
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCameraComponent*                 Default_Camera                                         (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::GetDefaultCamera(class UCameraComponent** Default_Camera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "GetDefaultCamera");

	Params::BP_PieceChar_C_GetDefaultCamera Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Default_Camera != nullptr)
		*Default_Camera = Parms.Default_Camera;
}


// Function BP_PieceChar.BP_PieceChar_C.CalcShootDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Shoot_Direction                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::CalcShootDirection(struct FVector* Shoot_Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "CalcShootDirection");

	Params::BP_PieceChar_C_CalcShootDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Shoot_Direction != nullptr)
		*Shoot_Direction = std::move(Parms.Shoot_Direction);
}


// Function BP_PieceChar.BP_PieceChar_C.OnRep_RepresentedPiece
// (BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::OnRep_RepresentedPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "OnRep_RepresentedPiece");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.OnRep_Black
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_PieceChar_C::OnRep_Black()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "OnRep_Black");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PieceChar.BP_PieceChar_C.FalloffFromDistance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PieceChar_C::FalloffFromDistance(float Distance, float* Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PieceChar_C", "FalloffFromDistance");

	Params::BP_PieceChar_C_FalloffFromDistance Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	if (Damage != nullptr)
		*Damage = Parms.Damage;
}

}

